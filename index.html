<!DOCTYPE html><html><head><script src="packages/web_components/webcomponents.min.js"></script>
<script src="packages/web_components/dart_support.js"></script>

  <title>Dylan Powers</title>
  <meta charset="UTF-8" name="viewport" content="width=device-width, initial-scale=1">

  <script src="packages/web_components/interop_support.js"></script>
  
  <script type="text/javascript" src="g_analytics.js"></script>

  <style>@font-face {
    font-family: 'robotoregular';
    src: url(font/Roboto-Regular.ttf);
    font-weight: normal;
    font-style: normal;
}</style>
  <style>.center {
  display: block;
  margin-left: auto;
  margin-right: auto;
  position: relative;
  text-align: center;
  width: 50%; }

a,
a:link,
a:visited,
a:active {
  color: rgba(0, 0, 0, 0.87);
  font-family: robotoregular, sans-serif;
  outline: none;
  -webkit-tap-highlight-color: rgba(255, 255, 255, 0); }

a,
h1,
h2,
h3,
h4,
h5,
h6,
p {
  color: rgba(0, 0, 0, 0.87);
  font-family: robotoregular, sans-serif; }

body {
  background-color: #EEE;
  margin: 0; }

#cards {
  max-width: 1488px;
  width: 100%; }

@media (min-width: 1503px) {
  .left {
    clear: left;
    float: left; }

  .right {
    clear: right;
    float: right; } }
</style>
  <link rel="shortcut icon" href="cat_computer_65px.png">

  
  
  
  
  
  
  
</head>
<body><div hidden=""><style shim-shadowdom="">
/*******************************
          Flex Layout
*******************************/

html /deep/ [layout][horizontal], html /deep/ [layout][vertical] {
  display: -ms-flexbox;
  display: -webkit-flex;
  display: flex;
}

html /deep/ [layout][horizontal][inline], html /deep/ [layout][vertical][inline] {
  display: -ms-inline-flexbox;
  display: -webkit-inline-flex;
  display: inline-flex;
}

html /deep/ [layout][horizontal] {
  -ms-flex-direction: row;
  -webkit-flex-direction: row;
  flex-direction: row;
}

html /deep/ [layout][horizontal][reverse] {
  -ms-flex-direction: row-reverse;
  -webkit-flex-direction: row-reverse;
  flex-direction: row-reverse;
}

html /deep/ [layout][vertical] {
  -ms-flex-direction: column;
  -webkit-flex-direction: column;
  flex-direction: column;
}

html /deep/ [layout][vertical][reverse] {
  -ms-flex-direction: column-reverse;
  -webkit-flex-direction: column-reverse;
  flex-direction: column-reverse;
}

html /deep/ [layout][wrap] {
  -ms-flex-wrap: wrap;
  -webkit-flex-wrap: wrap;
  flex-wrap: wrap;
}

html /deep/ [layout][wrap-reverse] {
  -ms-flex-wrap: wrap-reverse;
  -webkit-flex-wrap: wrap-reverse;
  flex-wrap: wrap-reverse;
}

html /deep/ [flex] {
  -ms-flex: 1 1 0.000000001px;
  -webkit-flex: 1;
  flex: 1;
  -webkit-flex-basis: 0.000000001px;
  flex-basis: 0.000000001px;
}

html /deep/ [vertical][layout] > [flex][auto-vertical], html /deep/ [vertical][layout]::shadow [flex][auto-vertical] {
  -ms-flex: 1 1 auto;
  -webkit-flex-basis: auto;
  flex-basis: auto;
}

html /deep/ [flex][auto] {
  -ms-flex: 1 1 auto;
  -webkit-flex-basis: auto;
  flex-basis: auto;
}

html /deep/ [flex][none] {
  -ms-flex: none;
  -webkit-flex: none;
  flex: none;
}

html /deep/ [flex][one] {
  -ms-flex: 1;
  -webkit-flex: 1;
  flex: 1;
}

html /deep/ [flex][two] {
  -ms-flex: 2;
  -webkit-flex: 2;
  flex: 2;
}

html /deep/ [flex][three] {
  -ms-flex: 3;
  -webkit-flex: 3;
  flex: 3;
}

html /deep/ [flex][four] {
  -ms-flex: 4;
  -webkit-flex: 4;
  flex: 4;
}

html /deep/ [flex][five] {
  -ms-flex: 5;
  -webkit-flex: 5;
  flex: 5;
}

html /deep/ [flex][six] {
  -ms-flex: 6;
  -webkit-flex: 6;
  flex: 6;
}

html /deep/ [flex][seven] {
  -ms-flex: 7;
  -webkit-flex: 7;
  flex: 7;
}

html /deep/ [flex][eight] {
  -ms-flex: 8;
  -webkit-flex: 8;
  flex: 8;
}

html /deep/ [flex][nine] {
  -ms-flex: 9;
  -webkit-flex: 9;
  flex: 9;
}

html /deep/ [flex][ten] {
  -ms-flex: 10;
  -webkit-flex: 10;
  flex: 10;
}

html /deep/ [flex][eleven] {
  -ms-flex: 11;
  -webkit-flex: 11;
  flex: 11;
}

html /deep/ [flex][twelve] {
  -ms-flex: 12;
  -webkit-flex: 12;
  flex: 12;
}

/* alignment in cross axis */

html /deep/ [layout][start] {
  -ms-flex-align: start;
  -webkit-align-items: flex-start;
  align-items: flex-start;
}

html /deep/ [layout][center], html /deep/ [layout][center-center] {
  -ms-flex-align: center;
  -webkit-align-items: center;
  align-items: center;
}

html /deep/ [layout][end] {
  -ms-flex-align: end;
  -webkit-align-items: flex-end;
  align-items: flex-end;
}

/* alignment in main axis */

html /deep/ [layout][start-justified] {
  -ms-flex-pack: start;
  -webkit-justify-content: flex-start;
  justify-content: flex-start;
}

html /deep/ [layout][center-justified], html /deep/ [layout][center-center] {
  -ms-flex-pack: center;
  -webkit-justify-content: center;
  justify-content: center;
}

html /deep/ [layout][end-justified] {
  -ms-flex-pack: end;
  -webkit-justify-content: flex-end;
  justify-content: flex-end;
}

html /deep/ [layout][around-justified] {
  -ms-flex-pack: distribute;
  -webkit-justify-content: space-around;
  justify-content: space-around;
}

html /deep/ [layout][justified] {
  -ms-flex-pack: justify;
  -webkit-justify-content: space-between;
  justify-content: space-between;
}

/* self alignment */

html /deep/ [self-start] {
  -ms-align-self: flex-start;
  -webkit-align-self: flex-start;
  align-self: flex-start;
}

html /deep/ [self-center] {
  -ms-align-self: center;
  -webkit-align-self: center;
  align-self: center;
}

html /deep/ [self-end] {
  -ms-align-self: flex-end;
  -webkit-align-self: flex-end;
  align-self: flex-end;
}

html /deep/ [self-stretch] {
  -ms-align-self: stretch;
  -webkit-align-self: stretch;
  align-self: stretch;
}

/*******************************
          Other Layout
*******************************/

html /deep/ [block] {
  display: block;
}

/* ie support for hidden */
html /deep/ [hidden] {
  display: none !important;
}

html /deep/ [relative] {
  position: relative;
}

html /deep/ [fit] {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}

body[fullbleed] {
  margin: 0;
  height: 100vh;
}

/*******************************
            Other
*******************************/

html /deep/ [segment], html /deep/ segment {
  display: block;
  position: relative;
  -webkit-box-sizing: border-box;
  -ms-box-sizing: border-box;
  box-sizing: border-box;
  margin: 1em 0.5em;
  padding: 1em;
  background-color: white;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1);
  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1);
  border-radius: 5px 5px 5px 5px;
}

</style>

<script src="packages/polymer/src/js/polymer/polymer.min.js"></script>

<script>
// TODO(sigmund): remove this script tag (dartbug.com/19650). This empty
// script tag is necessary to work around a bug in Chrome 36.
</script>

<!-- unminified for debugging:
<link rel="import" href="src/js/polymer/layout.html">
<script src="src/js/polymer/polymer.js"></script>
-->

<script src="packages/web_components/interop_support.js"></script>

<!-- Dart note: load polymer for Dart and JS from the same place -->

<script>
// This empty script is here to workaround issue
// https://github.com/dart-lang/core-elements/issues/11
</script>


<!-- Dart note: load polymer for Dart and JS from the same place -->

<script>
// This empty script is here to workaround issue
// https://github.com/dart-lang/core-elements/issues/11
</script>




<polymer-element name="core-meta" attributes="label type" hidden="">
<script>

  (function() {
    
    var SKIP_ID = 'meta';
    var metaData = {}, metaArray = {};

    Polymer('core-meta', {
      
      /**
       * The type of meta-data.  All meta-data with the same type with be
       * stored together.
       * 
       * @attribute type
       * @type string
       * @default 'default'
       */
      type: 'default',
      
      alwaysPrepare: true,
      
      ready: function() {
        this.register(this.id);
      },
      
      get metaArray() {
        var t = this.type;
        if (!metaArray[t]) {
          metaArray[t] = [];
        }
        return metaArray[t];
      },
      
      get metaData() {
        var t = this.type;
        if (!metaData[t]) {
          metaData[t] = {};
        }
        return metaData[t];
      },
      
      register: function(id, old) {
        if (id && id !== SKIP_ID) {
          this.unregister(this, old);
          this.metaData[id] = this;
          this.metaArray.push(this);
        }
      },
      
      unregister: function(meta, id) {
        delete this.metaData[id || meta.id];
        var i = this.metaArray.indexOf(meta);
        if (i >= 0) {
          this.metaArray.splice(i, 1);
        }
      },
      
      /**
       * Returns a list of all meta-data elements with the same type.
       * 
       * @property list
       * @type array
       * @default []
       */
      get list() {
        return this.metaArray;
      },
      
      /**
       * Retrieves meta-data by ID.
       *
       * @method byId
       * @param {String} id The ID of the meta-data to be returned.
       * @returns Returns meta-data.
       */
      byId: function(id) {
        return this.metaData[id];
      }
      
    });
    
  })();
  
</script>
</polymer-element>


<polymer-element name="core-transition" extends="core-meta">
  
  <script>
    Polymer('core-transition', {
      
      type: 'transition',

      /**
       * Run the animation.
       *
       * @method go
       * @param {Node} node The node to apply the animation on
       * @param {Object} state State info
       */
      go: function(node, state) {
        this.complete(node);
      },

      /**
       * Set up the animation. This may include injecting a stylesheet,
       * applying styles, creating a web animations object, etc.. This
       *
       * @method setup
       * @param {Node} node The animated node
       */
      setup: function(node) {
      },

      /**
       * Tear down the animation.
       *
       * @method teardown
       * @param {Node} node The animated node
       */
      teardown: function(node) {
      },

      /**
       * Called when the animation completes. This function also fires the
       * `core-transitionend` event.
       *
       * @method complete
       * @param {Node} node The animated node
       */
      complete: function(node) {
        this.fire('core-transitionend', null, node);
      },

      /**
       * Utility function to listen to an event on a node once.
       *
       * @method listenOnce
       * @param {Node} node The animated node
       * @param {string} event Name of an event
       * @param {Function} fn Event handler
       * @param {Array} args Additional arguments to pass to `fn`
       */
      listenOnce: function(node, event, fn, args) {
        var self = this;
        var listener = function() {
          fn.apply(self, args);
          node.removeEventListener(event, listener, false);
        }
        node.addEventListener(event, listener, false);
      }

    });
  </script>
</polymer-element>



<polymer-element name="core-key-helper">
  <script>
    Polymer('core-key-helper', {
      ENTER_KEY: 13,
      ESCAPE_KEY: 27
    });
  </script>
</polymer-element>



<polymer-element name="core-overlay-layer">
<template>
  <style>
    :host {
      position: fixed;
      top: 0;
      left: 0;
      z-index: 1000;
      display: none;
    }

    :host(.core-opened) {
      display: block;
    }
  </style>
  <content></content>
</template>
<script>
(function() {

  Polymer('core-overlay-layer', {
    publish: {
      opened: false
    },
    openedChanged: function() {
      this.classList.toggle('core-opened', this.opened);
    },
    /**
     * Adds an element to the overlay layer
     */
    addElement: function(element) {
      if (!this.parentNode) {
        document.querySelector('body').appendChild(this);
      }
      if (element.parentNode !== this) {
        element.__contents = [];
        var ip$ = element.querySelectorAll('content');
        for (var i=0, l=ip$.length, n; (i<l) && (n = ip$[i]); i++) {
          this.moveInsertedElements(n);
          this.cacheDomLocation(n);
          n.parentNode.removeChild(n);
          element.__contents.push(n);
        }
        this.cacheDomLocation(element);
        this.updateEventController(element);
        var h = this.makeHost();
        h.shadowRoot.appendChild(element);
        element.__host = h;
      }
    },
    makeHost: function() {
      var h = document.createElement('overlay-host');
      h.createShadowRoot();
      this.appendChild(h);
      return h;
    },
    moveInsertedElements: function(insertionPoint) {
      var n$ = insertionPoint.getDistributedNodes();
      var parent = insertionPoint.parentNode;
      insertionPoint.__contents = [];
      for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {
        this.cacheDomLocation(n);
        this.updateEventController(n);
        insertionPoint.__contents.push(n);
        parent.appendChild(n);  
      }
    },
    updateEventController: function(element) {
      element.eventController = this.element.findController(element);
    },
    /**
     * Removes an element from the overlay layer
     */
    removeElement: function(element) {
      element.eventController = null;
      this.replaceElement(element);
      var h = element.__host;
      if (h) {
        h.parentNode.removeChild(h);
      }
    },
    replaceElement: function(element) {
      if (element.__contents) {
        for (var i=0, c$=element.__contents, c; (c=c$[i]); i++) {
          this.replaceElement(c);
        }
        element.__contents = null;
      }
      if (element.__parentNode) {
        var n = element.__nextElementSibling && element.__nextElementSibling 
            === element.__parentNode ? element.__nextElementSibling : null;
        element.__parentNode.insertBefore(element, n);
      }
    },
    cacheDomLocation: function(element) {
      element.__nextElementSibling = element.nextElementSibling;
      element.__parentNode = element.parentNode;
    }
  });
  
})();
</script>
</polymer-element>


<!--
The `core-overlay` element displays overlayed on top of other content. It starts
out hidden and is displayed by setting its `opened` property to true.
A `core-overlay's` opened state can be toggled by calling the `toggle`
method.

The `core-overlay` will, by default, show/hide itself when it's opened. The 
`target` property may be set to another element to cause that element to 
be shown when the overlay is opened.

It's common to want a `core-overlay` to animate to its opened
position. The `core-overlay` element uses a `core-transition` to handle
animation. The default transition is `core-transition-fade` which 
causes the overlay to fade in when displayed. See 
<a href="../core-transition/">`core-transition`</a> for more
information about customizing a `core-overlay's` opening animation. The
`backdrop` property can be set to true to show a backdrop behind the overlay
that will darken the rest of the window.

An element that should close the `core-overlay` will automatically
do so if it's given the `core-overlay-toggle` attribute. This attribute
can be customized with the `closeAttribute` property. You can also use
`closeSelector` if more general matching is needed.

By default  `core-overlay` will close whenever the user taps outside it or
presses the escape key. This behavior can be turned off via the
`autoCloseDisabled` property.

    <core-overlay>
      <h2>Dialog</h2>
      <input placeholder="say something..." autofocus>
      <div>I agree with this wholeheartedly.</div>
      <button core-overlay-toggle>OK</button>
    </core-overlay>

`core-overlay` will automatically size and position itself according to the 
following rules. The overlay's size is constrained such that it does not
overflow the screen. This is done by setting maxHeight/maxWidth on the 
`sizingTarget`. If the `sizingTarget` already has a setting for one of these
properties, it will not be overridden. The overlay should
be positioned via css or imperatively using the `core-overlay-position` event.
If the overlay is not positioned vertically via setting `top` or `bottom`, it
will be centered vertically. The same is true horizontally via a setting to 
`left` or `right`. In addition, css `margin` can be used to provide some space
around the overlay. This can be used to ensure
that, for example, a drop shadow is always visible around the overlay.

@group Core Elements
@element core-overlay
@homepage github.io
-->
<!--
Fired when the `core-overlay`'s `opened` property changes.

@event core-overlay-open
@param {Object} detail
@param {Object} detail.opened the opened state
-->
<!--
Fired when the `core-overlay` has completely opened.

@event core-overlay-open-completed
-->
<!--
Fired when the `core-overlay` has completely closed.

@event core-overlay-close-completed
-->
<!--
Fired when the `core-overlay` needs to position itself. Optionally, implement
in order to position an overlay via code. If the overlay was not otherwise
positioned, it's important to indicate how the overlay has been positioned by
setting the `dimensions.position` object. For example, if the overlay has been
positioned via setting `right` and `top`, set dimensions.position to an
object like this: `{v: 'top', h: 'right'}`.

@event core-overlay-position
@param {Object} detail
@param {Object} detail.target the overlay target
@param {Object} detail.sizingTarget the overlay sizing target
@param {Object} detail.opened the opened state
-->
<style>
  .core-overlay-backdrop {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: black;
    opacity: 0;
    transition: opacity 0.2s;
  }

  .core-overlay-backdrop.core-opened {
    opacity: 0.6;
  }
</style>

<polymer-element name="core-overlay">
<script>
(function() {

  Polymer('core-overlay', {

    publish: {
      /**
       * The target element that will be shown when the overlay is 
       * opened. If unspecified, the core-overlay itself is the target.
       *
       * @attribute target
       * @type Object
       * @default the overlay element
       */
      target: null,


      /**
       * A `core-overlay`'s size is guaranteed to be 
       * constrained to the window size. To achieve this, the sizingElement
       * is sized with a max-height/width. By default this element is the 
       * target element, but it can be specifically set to a specific element
       * inside the target if that is more appropriate. This is useful, for 
       * example, when a region inside the overlay should scroll if needed.
       *
       * @attribute sizingTarget
       * @type Object
       * @default the target element
       */
      sizingTarget: null,
    
      /**
       * Set opened to true to show an overlay and to false to hide it.
       * A `core-overlay` may be made initially opened by setting its
       * `opened` attribute.
       * @attribute opened
       * @type boolean
       * @default false
       */
      opened: false,

      /**
       * If true, the overlay has a backdrop darkening the rest of the screen.
       * The backdrop element is attached to the document body and may be styled
       * with the class `core-overlay-backdrop`. When opened the `core-opened`
       * class is applied.
       *
       * @attribute backdrop
       * @type boolean
       * @default false
       */    
      backdrop: false,

      /**
       * If true, the overlay is guaranteed to display above page content.
       *
       * @attribute layered
       * @type boolean
       * @default false
      */
      layered: false,
    
      /**
       * By default an overlay will close automatically if the user
       * taps outside it or presses the escape key. Disable this
       * behavior by setting the `autoCloseDisabled` property to true.
       * @attribute autoCloseDisabled
       * @type boolean
       * @default false
       */
      autoCloseDisabled: false,

      /**
       * By default an overlay will focus its target or an element inside
       * it with the `autoFocus` attribute. Disable this
       * behavior by setting the `autoFocusDisabled` property to true.
       * @attribute autoFocusDisabled
       * @type boolean
       * @default false
       */
      autoFocusDisabled: false,

      /**
       * This property specifies an attribute on elements that should
       * close the overlay on tap. Should not set `closeSelector` if this
       * is set.
       *
       * @attribute closeAttribute
       * @type string
       * @default "core-overlay-toggle"
       */
      closeAttribute: 'core-overlay-toggle',

      /**
       * This property specifies a selector matching elements that should
       * close the overlay on tap. Should not set `closeAttribute` if this
       * is set.
       *
       * @attribute closeSelector
       * @type string
       * @default ""
       */
      closeSelector: '',

      /**
       * The transition property specifies a string which identifies a 
       * <a href="../core-transition/">`core-transition`</a> element that 
       * will be used to help the overlay open and close. The default
       * `core-transition-fade` will cause the overlay to fade in and out.
       *
       * @attribute transition
       * @type string
       * @default 'core-transition-fade'
       */
      transition: 'core-transition-fade'

    },

    captureEventName: 'tap',
    targetListeners: {
      'tap': 'tapHandler',
      'keydown': 'keydownHandler',
      'core-transitionend': 'transitionend'
    },
    
    registerCallback: function(element) {
      this.layer = document.createElement('core-overlay-layer');
      this.keyHelper = document.createElement('core-key-helper');
      this.meta = document.createElement('core-transition');
      this.scrim = document.createElement('div');
      this.scrim.className = 'core-overlay-backdrop';
    },

    ready: function() {
      this.target = this.target || this;
      // flush to ensure styles are installed before paint
      Polymer.flush();
    },

    /** 
     * Toggle the opened state of the overlay.
     * @method toggle
     */
    toggle: function() {
      this.opened = !this.opened;
    },

    /** 
     * Open the overlay. This is equivalent to setting the `opened`
     * property to true.
     * @method open
     */
    open: function() {
      this.opened = true;
    },

    /** 
     * Close the overlay. This is equivalent to setting the `opened` 
     * property to false.
     * @method close
     */
    close: function() {
      this.opened = false;
    },

    domReady: function() {
      this.ensureTargetSetup();
    },

    targetChanged: function(old) {
      if (this.target) {
        // really make sure tabIndex is set
        if (this.target.tabIndex < 0) {
          this.target.tabIndex = -1;
        }
        this.addElementListenerList(this.target, this.targetListeners);
        this.target.style.display = 'none';
        this.target.__overlaySetup = false;
      }
      if (old) {
        this.removeElementListenerList(old, this.targetListeners);
        var transition = this.getTransition();
        if (transition) {
          transition.teardown(old);
        } else {
          old.style.position = '';
          old.style.outline = '';
        }
        old.style.display = '';
      }
    },

    transitionChanged: function(old) {
      if (!this.target) {
        return;
      }
      if (old) {
        this.getTransition(old).teardown(this.target);
      }
      this.target.__overlaySetup = false;
    },

    // NOTE: wait to call this until we're as sure as possible that target
    // is styled.
    ensureTargetSetup: function() {
      if (!this.target || this.target.__overlaySetup) {
        return;
      }
      if (!this.sizingTarget) {
        this.sizingTarget = this.target;
      }
      this.target.__overlaySetup = true;
      this.target.style.display = '';
      var transition = this.getTransition();
      if (transition) {
        transition.setup(this.target);
      }
      var style = this.target.style;
      var computed = getComputedStyle(this.target);
      if (computed.position === 'static') {
        style.position = 'fixed';
      }
      style.outline = 'none';
      style.display = 'none';
    },

    openedChanged: function() {
      this.transitioning = true;
      this.ensureTargetSetup();
      this.prepareRenderOpened();
      // async here to allow overlay layer to become visible.
      this.async(function() {
        this.target.style.display = '';
        // force layout to ensure transitions will go
        this.target.offsetWidth;
        this.renderOpened();
      });
      this.fire('core-overlay-open', this.opened);
    },

    // tasks which must occur before opening; e.g. making the element visible
    prepareRenderOpened: function() {
      if (this.opened) {
        addOverlay(this);
      }
      this.prepareBackdrop();
      // async so we don't auto-close immediately via a click.
      this.async(function() {
        if (!this.autoCloseDisabled) {
          this.enableElementListener(this.opened, document,
              this.captureEventName, 'captureHandler', true);
        }
      });
      this.enableElementListener(this.opened, window, 'resize',
          'resizeHandler');

      if (this.opened) {
        // force layout so SD Polyfill renders
        this.target.offsetHeight;
        this.discoverDimensions();
        // if we are showing, then take care when positioning
        this.preparePositioning();
        this.positionTarget();
        this.updateTargetDimensions();
        this.finishPositioning();
        if (this.layered) {
          this.layer.addElement(this.target);
          this.layer.opened = this.opened;
        }
      }
    },

    // tasks which cause the overlay to actually open; typically play an
    // animation
    renderOpened: function() {
      var transition = this.getTransition();
      if (transition) {
        transition.go(this.target, {opened: this.opened});
      } else {
        this.transitionend();
      }
      this.renderBackdropOpened();
    },

    // finishing tasks; typically called via a transition
    transitionend: function(e) {
      // make sure this is our transition event.
      if (e && e.target !== this.target) {
        return;
      }
      this.transitioning = false;
      if (!this.opened) {
        this.resetTargetDimensions();
        this.target.style.display = 'none';
        this.completeBackdrop();
        removeOverlay(this);
        if (this.layered) {
          if (!currentOverlay()) {
            this.layer.opened = this.opened;
          }
          this.layer.removeElement(this.target);
        }
      }
      this.fire('core-overlay-' + (this.opened ? 'open' : 'close') + 
          '-completed');
      this.applyFocus();
    },

    prepareBackdrop: function() {
      if (this.backdrop && this.opened) {
        if (!this.scrim.parentNode) {
          document.body.appendChild(this.scrim);
          this.scrim.style.zIndex = currentOverlayZ() - 1;
        }
        trackBackdrop(this);
      }
    },

    renderBackdropOpened: function() {
      if (this.backdrop && getBackdrops().length < 2) {
        this.scrim.classList.toggle('core-opened', this.opened);
      }
    },

    completeBackdrop: function() {
      if (this.backdrop) {
        trackBackdrop(this);
        if (getBackdrops().length === 0) {
          this.scrim.parentNode.removeChild(this.scrim);
        }
      }
    },

    preparePositioning: function() {
      this.target.style.transition = this.target.style.webkitTransition = 'none';
      this.target.style.transform = this.target.style.webkitTransform = 'none';
      this.target.style.display = '';
    },

    discoverDimensions: function() {
      if (this.dimensions) {
        return;
      }
      var target = getComputedStyle(this.target);
      var sizer = getComputedStyle(this.sizingTarget);
      this.dimensions = {
        position: {
          v: target.top !== 'auto' ? 'top' : (target.bottom !== 'auto' ?
            'bottom' : null),
          h: target.left !== 'auto' ? 'left' : (target.right !== 'auto' ?
            'right' : null),
          css: target.position
        },
        size: {
          v: sizer.maxHeight !== 'none',
          h: sizer.maxWidth !== 'none'
        },
        margin: {
          top: parseInt(target.marginTop) || 0,
          right: parseInt(target.marginRight) || 0,
          bottom: parseInt(target.marginBottom) || 0,
          left: parseInt(target.marginLeft) || 0
        }
      };
    },

    finishPositioning: function(target) {
      this.target.style.display = 'none';
      this.target.style.transform = this.target.style.webkitTransform = '';
      // force layout to avoid application of transform
      this.target.offsetWidth;
      this.target.style.transition = this.target.style.webkitTransition = '';
    },

    getTransition: function(name) {
      return this.meta.byId(name || this.transition);
    },

    getFocusNode: function() {
      return this.target.querySelector('[autofocus]') || this.target;
    },

    applyFocus: function() {
      var focusNode = this.getFocusNode();
      if (this.opened) {
        if (!this.autoFocusDisabled) {
          focusNode.focus();
        }
      } else {
        focusNode.blur();
        if (currentOverlay() == this) {
          console.warn('Current core-overlay is attempting to focus itself as next! (bug)');
        } else {
          focusOverlay();
        }
      }
    },

    positionTarget: function() {
      // fire positioning event
      this.fire('core-overlay-position', {target: this.target,
          sizingTarget: this.sizingTarget, opened: this.opened});
      if (!this.dimensions.position.v) {
        this.target.style.top = '0px';
      }
      if (!this.dimensions.position.h) {
        this.target.style.left = '0px';
      }
    },

    updateTargetDimensions: function() {
      this.sizeTarget();
      this.repositionTarget();
    },

    sizeTarget: function() {
      this.sizingTarget.style.boxSizing = 'border-box';
      var dims = this.dimensions;
      var rect = this.target.getBoundingClientRect();
      if (!dims.size.v) {
        this.sizeDimension(rect, dims.position.v, 'top', 'bottom', 'Height');
      }
      if (!dims.size.h) {
        this.sizeDimension(rect, dims.position.h, 'left', 'right', 'Width');
      }
    },

    sizeDimension: function(rect, positionedBy, start, end, extent) {
      var dims = this.dimensions;
      var flip = (positionedBy === end);
      var m = flip ? start : end;
      var ws = window['inner' + extent];
      var o = dims.margin[m] + (flip ? ws - rect[end] : 
          rect[start]);
      var offset = 'offset' + extent;
      var o2 = this.target[offset] - this.sizingTarget[offset];
      this.sizingTarget.style['max' + extent] = (ws - o - o2) + 'px';
    },

    // vertically and horizontally center if not positioned
    repositionTarget: function() {
      // only center if position fixed.      
      if (this.dimensions.position.css !== 'fixed') {
        return; 
      }
      if (!this.dimensions.position.v) {
        var t = (window.innerHeight - this.target.offsetHeight) / 2;
        t -= this.dimensions.margin.top;
        this.target.style.top = t + 'px';
      }

      if (!this.dimensions.position.h) {
        var l = (window.innerWidth - this.target.offsetWidth) / 2;
        l -= this.dimensions.margin.left;
        this.target.style.left = l + 'px';
      }
    },

    resetTargetDimensions: function() {
      if (!this.dimensions || !this.dimensions.size.v) {
        this.sizingTarget.style.maxHeight = '';  
        this.target.style.top = '';
      }
      if (!this.dimensions || !this.dimensions.size.h) {
        this.sizingTarget.style.maxWidth = '';  
        this.target.style.left = '';
      }
      this.dimensions = null;
    },

    tapHandler: function(e) {
      // closeSelector takes precedence since closeAttribute has a default non-null value.
      if (e.target &&
          (this.closeSelector && e.target.matches(this.closeSelector)) ||
          (this.closeAttribute && e.target.hasAttribute(this.closeAttribute))) {
        this.toggle();
      } else {
        if (this.autoCloseJob) {
          this.autoCloseJob.stop();
          this.autoCloseJob = null;
        }
      }
    },
    
    // We use the traditional approach of capturing events on document
    // to to determine if the overlay needs to close. However, due to 
    // ShadowDOM event retargeting, the event target is not useful. Instead
    // of using it, we attempt to close asynchronously and prevent the close
    // if a tap event is immediately heard on the target.
    // TODO(sorvell): This approach will not work with modal. For
    // this we need a scrim.
    captureHandler: function(e) {
      if (!this.autoCloseDisabled && (currentOverlay() == this)) {
        this.autoCloseJob = this.job(this.autoCloseJob, function() {
          this.close();
        });
      }
    },

    keydownHandler: function(e) {
      if (!this.autoCloseDisabled && (e.keyCode == this.keyHelper.ESCAPE_KEY)) {
        this.close();
        e.stopPropagation();
      }
    },

    /**
     * Extensions of core-overlay should implement the `resizeHandler`
     * method to adjust the size and position of the overlay when the 
     * browser window resizes.
     * @method resizeHandler
     */
    resizeHandler: function() {
      this.updateTargetDimensions();
    },

    // TODO(sorvell): these utility methods should not be here.
    addElementListenerList: function(node, events) {
      for (var i in events) {
        this.addElementListener(node, i, events[i]);
      }
    },

    removeElementListenerList: function(node, events) {
      for (var i in events) {
        this.removeElementListener(node, i, events[i]);
      }
    },

    enableElementListener: function(enable, node, event, methodName, capture) {
      if (enable) {
        this.addElementListener(node, event, methodName, capture);
      } else {
        this.removeElementListener(node, event, methodName, capture);
      }
    },

    addElementListener: function(node, event, methodName, capture) {
      var fn = this._makeBoundListener(methodName);
      if (node && fn) {
        Polymer.addEventListener(node, event, fn, capture);
      }
    },

    removeElementListener: function(node, event, methodName, capture) {
      var fn = this._makeBoundListener(methodName);
      if (node && fn) {
        Polymer.removeEventListener(node, event, fn, capture);
      }
    },

    _makeBoundListener: function(methodName) {
      var self = this, method = this[methodName];
      if (!method) {
        return;
      }
      var bound = '_bound' + methodName;
      if (!this[bound]) {
        this[bound] = function(e) {
          method.call(self, e);
        };
      }
      return this[bound];
    },
  });

  // TODO(sorvell): This should be an element with private state so it can
  // be independent of overlay.
  // track overlays for z-index and focus managemant
  var overlays = [];
  function addOverlay(overlay) {
    var z0 = currentOverlayZ();
    overlays.push(overlay);
    var z1 = currentOverlayZ();
    if (z1 <= z0) {
      applyOverlayZ(overlay, z0);
    }
  }

  function removeOverlay(overlay) {
    var i = overlays.indexOf(overlay);
    if (i >= 0) {
      overlays.splice(i, 1);
      setZ(overlay, '');
    }
  }
  
  function applyOverlayZ(overlay, aboveZ) {
    setZ(overlay.target, aboveZ + 2);
  }
  
  function setZ(element, z) {
    element.style.zIndex = z;
  }

  function currentOverlay() {
    return overlays[overlays.length-1];
  }
  
  var DEFAULT_Z = 10;
  
  function currentOverlayZ() {
    var z;
    var current = currentOverlay();
    if (current) {
      var z1 = window.getComputedStyle(current.target).zIndex;
      if (!isNaN(z1)) {
        z = Number(z1);
      }
    }
    return z || DEFAULT_Z;
  }
  
  function focusOverlay() {
    var current = currentOverlay();
    // We have to be careful to focus the next overlay _after_ any current
    // transitions are complete (due to the state being toggled prior to the
    // transition). Otherwise, we risk infinite recursion when a transitioning
    // (closed) overlay becomes the current overlay.
    //
    // NOTE: We make the assumption that any overlay that completes a transition
    // will call into focusOverlay to kick the process back off. Currently:
    // transitionend -> applyFocus -> focusOverlay.
    if (current && !current.transitioning) {
      current.applyFocus();
    }
  }

  var backdrops = [];
  function trackBackdrop(element) {
    if (element.opened) {
      backdrops.push(element);
    } else {
      var i = backdrops.indexOf(element);
      if (i >= 0) {
        backdrops.splice(i, 1);
      }
    }
  }

  function getBackdrops() {
    return backdrops;
  }
})();
</script>
</polymer-element>


<style shim-shadowdom="">
  html /deep/ core-dropdown {
    position: absolute;
    overflow: auto;
    background-color: #fff;
  }
</style>

<polymer-element name="core-dropdown" extends="core-overlay">
<script>

(function() {

  function docElem(property) {
    var t;
    return ((t = document.documentElement) || (t = document.body.parentNode)) && (typeof t[property] === 'number') ? t : document.body;
  }

  // View width and height excluding any visible scrollbars
  // http://www.highdots.com/forums/javascript/faq-topic-how-do-i-296669.html
  //    1) document.client[Width|Height] always reliable when available, including Safari2
  //    2) document.documentElement.client[Width|Height] reliable in standards mode DOCTYPE, except for Safari2, Opera<9.5
  //    3) document.body.client[Width|Height] is gives correct result when #2 does not, except for Safari2
  //    4) When document.documentElement.client[Width|Height] is unreliable, it will be size of <html> element either greater or less than desired view size
  //       https://bugzilla.mozilla.org/show_bug.cgi?id=156388#c7
  //    5) When document.body.client[Width|Height] is unreliable, it will be size of <body> element less than desired view size
  function viewSize() {
    // This algorithm avoids creating test page to determine if document.documentElement.client[Width|Height] is greater then view size,
    // will succeed where such test page wouldn't detect dynamic unreliability,
    // and will only fail in the case the right or bottom edge is within the width of a scrollbar from edge of the viewport that has visible scrollbar(s).
    var doc = docElem('clientWidth');
    var body = document.body;
    var w, h;
    return typeof document.clientWidth === 'number' ?
      {w: document.clientWidth, h: document.clientHeight} :
      doc === body || (w = Math.max( doc.clientWidth, body.clientWidth )) > self.innerWidth || (h = Math.max( doc.clientHeight, body.clientHeight )) > self.innerHeight ?
        {w: body.clientWidth, h: body.clientHeight} : {w: w, h: h };
  }

  Polymer({

    publish: {

      /**
       * The element associated with this dropdown, usually the element that triggers
       * the menu. If unset, this property will default to the target's parent node
       * or shadow host.
       *
       * @attribute relatedTarget
       * @type Node
       */
      relatedTarget: null,

      /**
       * The horizontal alignment of the popup relative to `relatedTarget`. `left`
       * means the left edges are aligned together. `right` means the right edges
       * are aligned together.
       *
       * @attribute halign
       * @type 'left' | 'right'
       * @default 'left'
       */
      halign: 'left',

      /**
       * The vertical alignment of the popup relative to `relatedTarget`. `top` means
       * the top edges are aligned together. `bottom` means the bottom edges are
       * aligned together.
       *
       * @attribute valign
       * @type 'top' | 'bottom'
       * @default 'top'
       */
      valign: 'top',

    },

    measure: function() {
      var target = this.target;
      // remember position, because core-overlay may have set the property
      var pos = target.style.position;

      // get the size of the target as if it's positioned in the top left
      // corner of the screen
      target.style.position = 'fixed';
      target.style.left = '0px';
      target.style.top = '0px';

      var rect = target.getBoundingClientRect();

      target.style.position = pos;
      target.style.left = null;
      target.style.top = null;

      return rect;
    },

    resetTargetDimensions: function() {
      var dims = this.dimensions;
      var style = this.target.style;
      if (dims.position.h_by === this.localName) {
        style[dims.position.h] = null;
        dims.position.h_by = null;
      }
      if (dims.position.v_by === this.localName) {
        style[dims.position.v] = null;
        dims.position.v_by = null;
      }
      this.super();
    },

    positionTarget: function() {
      if (!this.relatedTarget) {
        this.relatedTarget = this.target.parentElement || (this.target.parentNode && this.target.parentNode.host);
        if (!this.relatedTarget) {
          this.super();
          return;
        }
      }

      // explicitly set width/height, because we don't want it constrained
      // to the offsetParent
      var target = this.sizingTarget;
      var rect = this.measure();
      target.style.width = Math.ceil(rect.width) + 'px';
      target.style.height = Math.ceil(rect.height) + 'px';

      if (this.layered) {
        this.positionLayeredTarget();
      } else {
        this.positionNestedTarget();
      }
    },

    positionLayeredTarget: function() {
      var target = this.target;
      var rect = this.relatedTarget.getBoundingClientRect();

      var dims = this.dimensions;
      var margin = dims.margin;
      var vp = viewSize();

      if (!dims.position.h) {
        if (this.halign === 'right') {
          target.style.right = vp.w - rect.right - margin.right + 'px';
          dims.position.h = 'right';
        } else {
          target.style.left = rect.left - margin.left + 'px';
          dims.position.h = 'left';
        }
        dims.position.h_by = this.localName;
      }

      if (!dims.position.v) {
        if (this.valign === 'bottom') {
          target.style.bottom = vp.h - rect.bottom - margin.bottom + 'px';
          dims.position.v = 'bottom';
        } else {
          target.style.top = rect.top - margin.top + 'px';
          dims.position.v = 'top';
        }
        dims.position.v_by = this.localName;
      }

      if (dims.position.h_by || dims.position.v_by) {
        target.style.position = 'fixed';
      }
    },

    positionNestedTarget: function() {
      var target = this.target;
      var related = this.relatedTarget;

      var t_op = target.offsetParent;
      var r_op = related.offsetParent;
      if (window.ShadowDOMPolyfill) {
        t_op = wrap(t_op);
        r_op = wrap(r_op);
      }

      if (t_op !== r_op && t_op !== related) {
        console.warn('core-dropdown-overlay: dropdown\'s offsetParent must be the relatedTarget or the relatedTarget\'s offsetParent!');
      }

      // Don't use CSS to handle halign/valign so we can use
      // dimensions.position to detect custom positioning

      var dims = this.dimensions;
      var margin = dims.margin;
      var inside = t_op === related;

      if (!dims.position.h) {
        if (this.halign === 'right') {
          target.style.right = ((inside ? 0 : t_op.offsetWidth - related.offsetLeft - related.offsetWidth) - margin.right) + 'px';
          dims.position.h = 'right';
        } else {
          target.style.left = ((inside ? 0 : related.offsetLeft) - margin.left) + 'px';
          dims.position.h = 'left';
        }
        dims.position.h_by = this.localName;
      }

      if (!dims.position.v) {
        if (this.valign === 'bottom') {
          target.style.bottom = ((inside ? 0 : t_op.offsetHeight - related.offsetTop - related.offsetHeight) - margin.bottom) + 'px';
          dims.position.v = 'bottom';
        } else {
          target.style.top = ((inside ? 0 : related.offsetTop) - margin.top) + 'px';
          dims.position.v = 'top';
        }
        dims.position.v_by = this.localName;
      }
    }

  });

})();

</script>
</polymer-element>


















<script>
// This empty script is here to workaround issue
// https://github.com/dart-lang/core-elements/issues/11
</script>


<style shim-shadowdom="">/*
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

html /deep/ paper-shadow,
html /deep/ paper-animated-shadow {
  display: block;
  position: relative;
}

html /deep/ paper-shadow::shadow #shadow-bottom,
html /deep/ paper-shadow::shadow #shadow-top {
  border-radius: inherit;
  pointer-events: none;
}

html /deep/ paper-shadow::shadow #shadow-bottom[animated],
html /deep/ paper-shadow::shadow #shadow-top[animated] {
  transition: box-shadow 0.28s cubic-bezier(0.4, 0, 0.2, 1);
}

html /deep/ .paper-shadow-top-z-1 {
  box-shadow: 0 2px 10px 0 rgba(0, 0, 0, 0.16);
}

html /deep/ .paper-shadow-bottom-z-1 {
  box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26);
}

html /deep/ .paper-shadow-top-z-2 {
  box-shadow: 0 6px 20px 0 rgba(0, 0, 0, 0.19);
}

html /deep/ .paper-shadow-bottom-z-2 {
  box-shadow: 0 8px 17px 0 rgba(0, 0, 0, 0.2);
}

html /deep/ .paper-shadow-top-z-3 {
  box-shadow: 0 17px 50px 0 rgba(0, 0, 0, 0.19);
}

html /deep/ .paper-shadow-bottom-z-3 {
  box-shadow: 0 12px 15px 0 rgba(0, 0, 0, 0.24);
}

html /deep/ .paper-shadow-top-z-4 {
  box-shadow: 0 25px 55px 0 rgba(0, 0, 0, 0.21);
}

html /deep/ .paper-shadow-bottom-z-4 {
  box-shadow: 0 16px 28px 0 rgba(0, 0, 0, 0.22);
}

html /deep/ .paper-shadow-top-z-5 {
  box-shadow: 0 40px 77px 0 rgba(0, 0, 0, 0.22);
}

html /deep/ .paper-shadow-bottom-z-5 {
  box-shadow: 0 27px 24px 0 rgba(0, 0, 0, 0.2);
}</style>

<polymer-element name="paper-shadow">

<template>

  <div id="shadow-bottom" fit="" animated?="[[animated]]" class="paper-shadow-bottom-z-[[z]]"></div>
  <div id="shadow-top" fit="" animated?="[[animated]]" class="paper-shadow-top-z-[[z]]"></div>

  <content></content>

</template>

<script>
  Polymer({

    publish: {

      /**
       * The z-depth of this shadow, from 0-5. Setting this property
       * after element creation has no effect. Use `setZ()` instead.
       *
       * @attribute z
       * @type number
       * @default 1
       */
      z: 1,

      /**
       * Set this to true to animate the shadow when setting a new
       * `z` value.
       *
       * @attribute animated
       * @type boolean
       * @default false
       */
      animated: false

    },

    /**
     * Set the z-depth of the shadow. This should be used after element
     * creation instead of setting the z property directly.
     *
     * @method setZ
     * @param {Number} newZ
     */
    setZ: function(newZ) {
      if (this.z !== newZ) {
        this.$['shadow-bottom'].classList.remove('paper-shadow-bottom-z-' + this.z);
        this.$['shadow-bottom'].classList.add('paper-shadow-bottom-z-' + newZ);
        this.$['shadow-top'].classList.remove('paper-shadow-top-z-' + this.z);
        this.$['shadow-top'].classList.add('paper-shadow-top-z-' + newZ);
        this.z = newZ;
      }
    }

  });
</script>
</polymer-element>





<polymer-element name="core-transition-css" extends="core-transition" attributes="transitionType">
<template>
  <style no-shim="">/* Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt */

:host(.core-transition) {
  outline: none;
  overflow: auto;
  opacity: 0;
  -webkit-transition: -webkit-transform 0.2s ease-in-out, opacity 0.2s ease-in;
  transition: transform 0.2s ease-in-out, opacity 0.2s ease-in;
}


:host(.core-transition.core-opened) {
  opacity: 1;
  -webkit-transform: translateZ(0);
  transform: translateZ(0);
}

:host(.core-transition-center) {
  -webkit-transform: scale(0.5);
  transform: scale(0.5);
}

:host(.core-transition-top) {
  -webkit-transform: translateY(-200%);
  transform: translateY(-200%);
}

:host(.core-transition-bottom) {
  -webkit-transform: translateY(200%);
  transform: translateY(200%);
}

:host(.core-transition-left) {
  -webkit-transform: translateX(-200%);
  transform: translateX(-200%);
}

:host(.core-transition-right) {
  -webkit-transform: translateX(200%);
  transform: translateX(200%);
}</style>
</template>
<script>

  Polymer('core-transition-css', {

    /**
     * The class that will be applied to all animated nodes.
     *
     * @attribute baseClass
     * @type string
     * @default "core-transition"
     */
    baseClass: 'core-transition',

    /**
     * The class that will be applied to nodes in the opened state.
     *
     * @attribute openedClass
     * @type string
     * @default "core-opened"
     */
    openedClass: 'core-opened',

    /**
     * The class that will be applied to nodes in the closed state.
     *
     * @attribute closedClass
     * @type string
     * @default "core-closed"
     */
    closedClass: 'core-closed',

    /**
     * Event to listen to for animation completion.
     *
     * @attribute completeEventName
     * @type string
     * @default "transitionEnd"
     */
    completeEventName: 'transitionend',

    publish: {
      /**
       * A secondary configuration attribute for the animation. The class
       * `<baseClass>-<transitionType` is applied to the animated node during
       * `setup`.
       *
       * @attribute transitionType
       * @type string
       */
      transitionType: null
    },

    registerCallback: function(element) {
      this.transitionStyle = element.templateContent().firstElementChild;
    },

    // template is just for loading styles, we don't need a shadowRoot
    fetchTemplate: function() {
      return null;
    },

    go: function(node, state) {
      if (state.opened !== undefined) {
        this.transitionOpened(node, state.opened);
      }
    },

    setup: function(node) {
      if (!node._hasTransitionStyle) {
        if (!node.shadowRoot) {
          node.createShadowRoot().innerHTML = '<content></content>';
        }
        this.installScopeStyle(this.transitionStyle, 'transition',
            node.shadowRoot);
        node._hasTransitionStyle = true;
      }
      node.classList.add(this.baseClass);
      if (this.transitionType) {
        node.classList.add(this.baseClass + '-' + this.transitionType);
      }
    },

    teardown: function(node) {
      node.classList.remove(this.baseClass);
      if (this.transitionType) {
        node.classList.remove(this.baseClass + '-' + this.transitionType);
      }
    },

    transitionOpened: function(node, opened) {
      this.listenOnce(node, this.completeEventName, function() {
        if (!opened) {
          node.classList.remove(this.closedClass);
        }
        this.complete(node);
      });
      node.classList.toggle(this.openedClass, opened);
      node.classList.toggle(this.closedClass, !opened);
    }

  });
</script>
</polymer-element>

<core-transition-css id="core-transition-fade"></core-transition-css>
<core-transition-css id="core-transition-center" transitiontype="center"></core-transition-css>
<core-transition-css id="core-transition-top" transitiontype="top"></core-transition-css>
<core-transition-css id="core-transition-bottom" transitiontype="bottom"></core-transition-css>
<core-transition-css id="core-transition-left" transitiontype="left"></core-transition-css>
<core-transition-css id="core-transition-right" transitiontype="right"></core-transition-css>




<script>
// This empty script is here to workaround issue
// https://github.com/dart-lang/core-elements/issues/11
</script>
<script src="packages/core_elements/src/web-animations-next/src/dev.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/scope.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/timing-utilities.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/normalize-keyframes.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/animation-node.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/effect.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/property-interpolation.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/animation.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/apply.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/element-animatable.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/interpolation.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/player.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/tick.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/handler-utils.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/shadow-handler.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/number-handler.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/visibility-handler.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/color-handler.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/dimension-handler.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/box-handler.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/transform-handler.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/property-names.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/timeline.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/maxifill-player.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/animation-constructor.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/effect-callback.js"></script>
<script src="packages/core_elements/src/web-animations-next/src/group-constructors.js"></script>





<script>
// This empty script is here to workaround issue
// https://github.com/dart-lang/core-elements/issues/11
</script>

<polymer-element name="paper-dropdown-transition" extends="core-transition-css">
  <template>
    <style no-shim="">/* Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt */

:host(.core-transition) #ripple,
:host(.core-transition) #background {
  opacity: 0;
}

:host(.core-transition) #scroller {
  opacity: 0;
}</style>
  </template>
  <script>
    Polymer('paper-dropdown-transition', {

      publish: {

        /**
         * The duration of the transition in ms. You can also set the duration by
         * setting a `duration` attribute on the target:
         *
         *    <paper-dropdown duration="1000"></paper-dropdown>
         *
         * @attribute duration
         * @type number
         * @default 500
         */
        duration: 500

      },

      setup: function(node) {
        this.super(arguments);

        var to = {
          'top': '0%',
          'left': '0%',
          'bottom': '100%',
          'right': '100%'
        };

        var bg = node.$.background;
        bg.style.webkitTransformOrigin = to[node.halign] + ' ' + to[node.valign];
        bg.style.transformOrigin = to[node.halign] + ' ' + to[node.valign];
      },

      transitionOpened: function(node, opened) {
        this.super(arguments);

        if (opened) {
          if (this.player) {
            this.player.cancel();
          }

          var duration = Number(node.getAttribute('duration')) || this.duration;

          var anims = [];

          var size = node.getBoundingClientRect();

          var ink = node.$.ripple;
          // var offset = 40 / Math.max(size.width, size.height);
          var offset = 0.2;
          anims.push(new Animation(ink, [{
            'opacity': 0.9,
            'transform': 'scale(0)',
          }, {
            'opacity': 0.9,
            'transform': 'scale(1)'
          }], {
            duration: duration * offset
          }));

          var bg = node.$.background;
          var sx = 40 / size.width;
          var sy = 40 / size.height;
          anims.push(new Animation(bg, [{
            'opacity': 0.9,
            'transform': 'scale(' + sx + ',' + sy + ')',
          }, {
            'opacity': 1,
            'transform': 'scale(' + Math.max(sx, 0.95) + ',' + Math.max(sy, 0.5) + ')'
          }, {
            'opacity': 1,
            'transform': 'scale(1, 1)'
          }], {
            delay: duration * offset,
            duration: duration * (1 - offset),
            fill: 'forwards'
          }));

          var menu = node.querySelector('.menu');
          if (menu) {
            var items = menu.items || menu.children.array();
            var itemDelay = offset + (1 - offset) / 2;
            var itemDuration = duration * (1 - itemDelay) / items.length;
            var reverse = this.valign === 'bottom';

            items.forEach(function(item, i) {
              anims.push(new Animation(item, [{
                'opacity': 0
              }, {
                'opacity': 1
              }], {
                delay: duration * itemDelay + itemDuration * (reverse ? items.length - 1 - i : i),
                duration: itemDuration,
                fill: 'both'
              }));
            }.bind(this));

            anims.push(new Animation(node.$.scroller, [{
              'opacity': 1
            }, {
              'opacity': 1
            }], {
              delay: duration * itemDelay,
              duration: itemDuration * items.length,
              fill: 'both'
            }));

          } else {
            anims.push(new Animation(node.$.scroller, [{
              'opacity': 0
            }, {
              'opacity': 1
            }], {
              delay: duration * (offset + (1 - offset) / 2),
              duration: duration * 0.5,
              fill: 'both'
            }));
          }

          var group = new AnimationGroup(anims, {
            easing: 'cubic-bezier(0.4, 0, 0.2, 1)'
          });
          this.player = document.timeline.play(group);
          this.player.onfinish = function() {
            this.fire('core-transitionend', this, node);
          }.bind(this);

        } else {
          this.fire('core-transitionend', this, node);
        }
      },

    });
  </script>
</polymer-element>

<paper-dropdown-transition id="paper-dropdown-transition"></paper-dropdown-transition>

<style shim-shadowdom="">
  html /deep/ paper-dropdown {
    position: absolute;
    overflow: visible;
    min-height: 40px;
  }
</style>

<polymer-element name="paper-dropdown" extends="core-dropdown">
<template>

  <style>
    #ripple {
      background-color: #fff;
      position: absolute;
      left: 0;
      top: 0;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.26);
      opacity: 0;
    }

    :host([halign=right]) #ripple {
      left: auto;
      right: 0;
    }

    :host([valign=bottom]) #ripple {
      top: auto;
      bottom: 0;
    }

    #background {
      background-color: #fff;
      border-radius: inherit;
    }

    #scroller {
      overflow: auto;
      box-sizing: border-box;
    }
  </style>

  <div id="ripple"></div>

  <div id="background" fit="">
    <paper-shadow fit=""></paper-shadow>
  </div>

  <div id="scroller" relative="">
    <content></content>
  </div>

</template>
<script>

  Polymer({

    publish: {
      transition: 'paper-dropdown-transition'
    },

    ready: function() {
      this.super();
      this.sizingTarget = this.$.scroller;
    }

  });

</script>
</polymer-element>















<script src="packages/core_elements/src/core-focusable/polymer-mixin.js"></script>
<script src="packages/core_elements/src/core-focusable/core-focusable.js"></script>



<script>
// This empty script is here to workaround issue
// https://github.com/dart-lang/core-elements/issues/11
</script>

<polymer-element name="paper-button-base" tabindex="0">

<script>

  (function() {

    var p = {

      eventDelegates: {
        down: 'downAction'
      },

      activeChanged: function() {
        this.super();

        if (this.$.ripple) {
          if (this.active) {
            // FIXME: remove when paper-ripple can have a default 'down' state.
            if (!this.lastEvent) {
              var rect = this.getBoundingClientRect();
              this.lastEvent = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
              }
            }
            this.$.ripple.downAction(this.lastEvent);
          } else {
            this.$.ripple.upAction();
          }
        }

        this.adjustZ();
      },

      disabledChanged: function() {
        this._disabledChanged();
        this.adjustZ();
      },

      recenteringTouchChanged: function() {
        if (this.$.ripple) {
          this.$.ripple.classList.toggle('recenteringTouch', this.recenteringTouch);
        }
      },

      fillChanged: function() {
        if (this.$.ripple) {
          this.$.ripple.classList.toggle('fill', this.fill);
        }
      },

      adjustZ: function() {
        if (!this.$.shadow) {
          return;
        }
        if (this.active) {
          this.$.shadow.setZ(2);
        } else if (this.disabled) {
          this.$.shadow.setZ(0);
        } else {
          this.$.shadow.setZ(1);
        }
      },

      downAction: function(e) {
        this._downAction();

        if (this.hasAttribute('noink')) {
          return;
        }

        this.lastEvent = e;
        if (!this.$.ripple) {
          var ripple = document.createElement('paper-ripple');
          ripple.setAttribute('id', 'ripple');
          ripple.setAttribute('fit', '');
          if (this.recenteringTouch) {
            ripple.classList.add('recenteringTouch');
          }
          if (!this.fill) {
            ripple.classList.add('circle');
          }
          this.$.ripple = ripple;
          this.shadowRoot.insertBefore(ripple, this.shadowRoot.firstChild);
          // No need to forward the event to the ripple because the ripple
          // is triggered in activeChanged
        }
      }

    };

    Polymer.mixin2(p, Polymer.CoreFocusable);
    Polymer(p);

  })();

</script>
</polymer-element>



<polymer-element name="paper-ripple" attributes="initialOpacity opacityDecayVelocity">
<template>

  <style>

    :host {
      display: block;
      position: relative;
      border-radius: inherit;
      overflow: hidden;
    }

    :host-context([noink]) {
      pointer-events: none;
    }

    #bg, #waves, .wave-container, .wave {
      pointer-events: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    #bg, .wave {
      opacity: 0;
    }

    #waves, .wave {
      overflow: hidden;
    }

    .wave-container, .wave {
      border-radius: 50%;
    }

    :host(.circle) #bg,
    :host(.circle) #waves {
      border-radius: 50%;
    }

    :host(.circle) .wave-container {
      overflow: hidden;
    }

  </style>

  <div id="bg"></div>
  <div id="waves">
  </div>

</template>
<script>

  (function() {

    var waveMaxRadius = 150;
    //
    // INK EQUATIONS
    //
    function waveRadiusFn(touchDownMs, touchUpMs, anim) {
      // Convert from ms to s
      var touchDown = touchDownMs / 1000;
      var touchUp = touchUpMs / 1000;
      var totalElapsed = touchDown + touchUp;
      var ww = anim.width, hh = anim.height;
      // use diagonal size of container to avoid floating point math sadness
      var waveRadius = Math.min(Math.sqrt(ww * ww + hh * hh), waveMaxRadius) * 1.1 + 5;
      var duration = 1.1 - .2 * (waveRadius / waveMaxRadius);
      var tt = (totalElapsed / duration);

      var size = waveRadius * (1 - Math.pow(80, -tt));
      return Math.abs(size);
    }

    function waveOpacityFn(td, tu, anim) {
      // Convert from ms to s.
      var touchDown = td / 1000;
      var touchUp = tu / 1000;
      var totalElapsed = touchDown + touchUp;

      if (tu <= 0) {  // before touch up
        return anim.initialOpacity;
      }
      return Math.max(0, anim.initialOpacity - touchUp * anim.opacityDecayVelocity);
    }

    function waveOuterOpacityFn(td, tu, anim) {
      // Convert from ms to s.
      var touchDown = td / 1000;
      var touchUp = tu / 1000;

      // Linear increase in background opacity, capped at the opacity
      // of the wavefront (waveOpacity).
      var outerOpacity = touchDown * 0.3;
      var waveOpacity = waveOpacityFn(td, tu, anim);
      return Math.max(0, Math.min(outerOpacity, waveOpacity));
    }

    // Determines whether the wave should be completely removed.
    function waveDidFinish(wave, radius, anim) {
      var waveOpacity = waveOpacityFn(wave.tDown, wave.tUp, anim);

      // If the wave opacity is 0 and the radius exceeds the bounds
      // of the element, then this is finished.
      return waveOpacity < 0.01 && radius >= Math.min(wave.maxRadius, waveMaxRadius);
    };

    function waveAtMaximum(wave, radius, anim) {
      var waveOpacity = waveOpacityFn(wave.tDown, wave.tUp, anim);

      return waveOpacity >= anim.initialOpacity && radius >= Math.min(wave.maxRadius, waveMaxRadius);
    }

    //
    // DRAWING
    //
    function drawRipple(ctx, x, y, radius, innerAlpha, outerAlpha) {
      // Only animate opacity and transform
      if (outerAlpha !== undefined) {
        ctx.bg.style.opacity = outerAlpha;
      }
      ctx.wave.style.opacity = innerAlpha;

      var s = radius / (ctx.containerSize / 2);
      var dx = x - (ctx.containerWidth / 2);
      var dy = y - (ctx.containerHeight / 2);

      ctx.wc.style.webkitTransform = 'translate3d(' + dx + 'px,' + dy + 'px,0)';
      ctx.wc.style.transform = 'translate3d(' + dx + 'px,' + dy + 'px,0)';

      // 2d transform for safari because of border-radius and overflow:hidden clipping bug.
      // https://bugs.webkit.org/show_bug.cgi?id=98538
      ctx.wave.style.webkitTransform = 'scale(' + s + ',' + s + ')';
      ctx.wave.style.transform = 'scale3d(' + s + ',' + s + ',1)';
    }

    //
    // SETUP
    //
    function createWave(elem) {
      var elementStyle = window.getComputedStyle(elem);
      var fgColor = elementStyle.color;

      var inner = document.createElement('div');
      inner.style.backgroundColor = fgColor;
      inner.classList.add('wave');

      var outer = document.createElement('div');
      outer.classList.add('wave-container');
      outer.appendChild(inner);

      var container = elem.$.waves;
      container.appendChild(outer);

      elem.$.bg.style.backgroundColor = fgColor;

      var wave = {
        bg: elem.$.bg,
        wc: outer,
        wave: inner,
        waveColor: fgColor,
        maxRadius: 0,
        isMouseDown: false,
        mouseDownStart: 0.0,
        mouseUpStart: 0.0,
        tDown: 0,
        tUp: 0
      };
      return wave;
    }

    function removeWaveFromScope(scope, wave) {
      if (scope.waves) {
        var pos = scope.waves.indexOf(wave);
        scope.waves.splice(pos, 1);
        // FIXME cache nodes
        wave.wc.remove();
      }
    };

    // Shortcuts.
    var pow = Math.pow;
    var now = Date.now;
    if (window.performance && performance.now) {
      now = performance.now.bind(performance);
    }

    function cssColorWithAlpha(cssColor, alpha) {
        var parts = cssColor.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
        if (typeof alpha == 'undefined') {
            alpha = 1;
        }
        if (!parts) {
          return 'rgba(255, 255, 255, ' + alpha + ')';
        }
        return 'rgba(' + parts[1] + ', ' + parts[2] + ', ' + parts[3] + ', ' + alpha + ')';
    }

    function dist(p1, p2) {
      return Math.sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));
    }

    function distanceFromPointToFurthestCorner(point, size) {
      var tl_d = dist(point, {x: 0, y: 0});
      var tr_d = dist(point, {x: size.w, y: 0});
      var bl_d = dist(point, {x: 0, y: size.h});
      var br_d = dist(point, {x: size.w, y: size.h});
      return Math.max(tl_d, tr_d, bl_d, br_d);
    }

    Polymer('paper-ripple', {

      /**
       * The initial opacity set on the wave.
       *
       * @attribute initialOpacity
       * @type number
       * @default 0.25
       */
      initialOpacity: 0.25,

      /**
       * How fast (opacity per second) the wave fades out.
       *
       * @attribute opacityDecayVelocity
       * @type number
       * @default 0.8
       */
      opacityDecayVelocity: 0.8,

      backgroundFill: true,
      pixelDensity: 2,

      eventDelegates: {
        down: 'downAction',
        up: 'upAction'
      },

      ready: function() {
        this.waves = [];
      },

      downAction: function(e) {
        var wave = createWave(this);

        this.cancelled = false;
        wave.isMouseDown = true;
        wave.tDown = 0.0;
        wave.tUp = 0.0;
        wave.mouseUpStart = 0.0;
        wave.mouseDownStart = now();

        var rect = this.getBoundingClientRect();
        var width = rect.width;
        var height = rect.height;
        var touchX = e.x - rect.left;
        var touchY = e.y - rect.top;

        wave.startPosition = {x:touchX, y:touchY};

        if (this.classList.contains("recenteringTouch")) {
          wave.endPosition = {x: width / 2,  y: height / 2};
          wave.slideDistance = dist(wave.startPosition, wave.endPosition);
        }
        wave.containerSize = Math.max(width, height);
        wave.containerWidth = width;
        wave.containerHeight = height;
        wave.maxRadius = distanceFromPointToFurthestCorner(wave.startPosition, {w: width, h: height});

        // The wave is circular so constrain its container to 1:1
        wave.wc.style.top = (wave.containerHeight - wave.containerSize) / 2 + 'px';
        wave.wc.style.left = (wave.containerWidth - wave.containerSize) / 2 + 'px';
        wave.wc.style.width = wave.containerSize + 'px';
        wave.wc.style.height = wave.containerSize + 'px';

        this.waves.push(wave);

        if (!this._loop) {
          this._loop = this.animate.bind(this, {
            width: width,
            height: height
          });
          requestAnimationFrame(this._loop);
        }
        // else there is already a rAF
      },

      upAction: function() {
        for (var i = 0; i < this.waves.length; i++) {
          // Declare the next wave that has mouse down to be mouse'ed up.
          var wave = this.waves[i];
          if (wave.isMouseDown) {
            wave.isMouseDown = false
            wave.mouseUpStart = now();
            wave.mouseDownStart = 0;
            wave.tUp = 0.0;
            break;
          }
        }
        this._loop && requestAnimationFrame(this._loop);
      },

      cancel: function() {
        this.cancelled = true;
      },

      animate: function(ctx) {
        var shouldRenderNextFrame = false;

        var deleteTheseWaves = [];
        // The oldest wave's touch down duration
        var longestTouchDownDuration = 0;
        var longestTouchUpDuration = 0;
        // Save the last known wave color
        var lastWaveColor = null;
        // wave animation values
        var anim = {
          initialOpacity: this.initialOpacity,
          opacityDecayVelocity: this.opacityDecayVelocity,
          height: ctx.height,
          width: ctx.width
        }

        for (var i = 0; i < this.waves.length; i++) {
          var wave = this.waves[i];

          if (wave.mouseDownStart > 0) {
            wave.tDown = now() - wave.mouseDownStart;
          }
          if (wave.mouseUpStart > 0) {
            wave.tUp = now() - wave.mouseUpStart;
          }

          // Determine how long the touch has been up or down.
          var tUp = wave.tUp;
          var tDown = wave.tDown;
          longestTouchDownDuration = Math.max(longestTouchDownDuration, tDown);
          longestTouchUpDuration = Math.max(longestTouchUpDuration, tUp);

          // Obtain the instantenous size and alpha of the ripple.
          var radius = waveRadiusFn(tDown, tUp, anim);
          var waveAlpha =  waveOpacityFn(tDown, tUp, anim);
          var waveColor = cssColorWithAlpha(wave.waveColor, waveAlpha);
          lastWaveColor = wave.waveColor;

          // Position of the ripple.
          var x = wave.startPosition.x;
          var y = wave.startPosition.y;

          // Ripple gravitational pull to the center of the canvas.
          if (wave.endPosition) {

            // This translates from the origin to the center of the view  based on the max dimension of
            var translateFraction = Math.min(1, radius / wave.containerSize * 2 / Math.sqrt(2) );

            x += translateFraction * (wave.endPosition.x - wave.startPosition.x);
            y += translateFraction * (wave.endPosition.y - wave.startPosition.y);
          }

          // If we do a background fill fade too, work out the correct color.
          var bgFillColor = null;
          if (this.backgroundFill) {
            var bgFillAlpha = waveOuterOpacityFn(tDown, tUp, anim);
            bgFillColor = cssColorWithAlpha(wave.waveColor, bgFillAlpha);
          }

          // Draw the ripple.
          drawRipple(wave, x, y, radius, waveAlpha, bgFillAlpha);

          // Determine whether there is any more rendering to be done.
          var maximumWave = waveAtMaximum(wave, radius, anim);
          var waveDissipated = waveDidFinish(wave, radius, anim);
          var shouldKeepWave = !waveDissipated || maximumWave;
          // keep rendering dissipating wave when at maximum radius on upAction
          var shouldRenderWaveAgain = wave.mouseUpStart ? !waveDissipated : !maximumWave;
          shouldRenderNextFrame = shouldRenderNextFrame || shouldRenderWaveAgain;
          if (!shouldKeepWave || this.cancelled) {
            deleteTheseWaves.push(wave);
          }
       }

        if (shouldRenderNextFrame) {
          requestAnimationFrame(this._loop);
        }

        for (var i = 0; i < deleteTheseWaves.length; ++i) {
          var wave = deleteTheseWaves[i];
          removeWaveFromScope(this, wave);
        }

        if (!this.waves.length && this._loop) {
          // clear the background color
          this.$.bg.style.backgroundColor = null;
          this._loop = null;
          this.fire('core-transitionend');
        }
      }

    });

  })();

</script>
</polymer-element>


<polymer-element name="paper-item" extends="paper-button-base">

  <template>

    <style>

      :host {
        display: block;
        position: relative;
        font-size: 16px;
        box-sizing: border-box;
        min-width: 7em;
        outline: none;
        -moz-user-select: none;
        -ms-user-select: none;
        -webkit-user-select: none;
        user-select: none;
        cursor: pointer;
        z-index: 0;
      }

      :host([disabled]) {
        color: #a8a8a8;
        cursor: auto;
        pointer-events: none;
      }

      :host(.core-selected) {
        background-color: #eaeaea;
      }

      #ripple {
        pointer-events: none;
        z-index: -1;
      }

      .button-content {
        height: 100%;
        padding: 0.9em 1em;
      }

      polyfill-next-selector { content: '.button-content > a'; }
      ::content > a {
        height: 100%;
        /* flex */
        -ms-flex: 1 1 0.000000001px;
        -webkit-flex: 1;
        flex: 1;
        -webkit-flex-basis: 0.000000001px;
        flex-basis: 0.000000001px;
      }

    </style>

    <!-- this div is needed to position the ripple behind text content -->
    <div class="button-content" relative="" layout="" horizontal="" center="">
      <content></content>
    </div>

  </template>

  <script>
    Polymer({

      publish: {

        /**
         * If true, the button will be styled with a shadow.
         *
         * @attribute raised
         * @type boolean
         * @default false
         */
        raised: false,

        /**
         * By default the ripple emanates from where the user touched the button.
         * Set this to true to always center the ripple.
         *
         * @attribute recenteringTouch
         * @type boolean
         * @default false
         */
        recenteringTouch: false,

        /**
         * By default the ripple expands to fill the button. Set this to false to
         * constrain the ripple to a circle within the button.
         *
         * @attribute fill
         * @type boolean
         * @default true
         */
        fill: true

      }

    });
  </script>
</polymer-element>














<style shim-shadowdom="">
  html /deep/ core-a11y-keys {
    display: none;
  }
</style>

<polymer-element name="core-a11y-keys">
<script>
  (function() {
    /*
     * Chrome uses an older version of DOM Level 3 Keyboard Events
     *
     * Most keys are labeled as text, but some are Unicode codepoints.
     * Values taken from: http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/keyset.html#KeySet-Set
     */
    var KEY_IDENTIFIER = {
      'U+0009': 'tab',
      'U+001B': 'esc',
      'U+0020': 'space',
      'U+002A': '*',
      'U+0030': '0',
      'U+0031': '1',
      'U+0032': '2',
      'U+0033': '3',
      'U+0034': '4',
      'U+0035': '5',
      'U+0036': '6',
      'U+0037': '7',
      'U+0038': '8',
      'U+0039': '9',
      'U+0041': 'a',
      'U+0042': 'b',
      'U+0043': 'c',
      'U+0044': 'd',
      'U+0045': 'e',
      'U+0046': 'f',
      'U+0047': 'g',
      'U+0048': 'h',
      'U+0049': 'i',
      'U+004A': 'j',
      'U+004B': 'k',
      'U+004C': 'l',
      'U+004D': 'm',
      'U+004E': 'n',
      'U+004F': 'o',
      'U+0050': 'p',
      'U+0051': 'q',
      'U+0052': 'r',
      'U+0053': 's',
      'U+0054': 't',
      'U+0055': 'u',
      'U+0056': 'v',
      'U+0057': 'w',
      'U+0058': 'x',
      'U+0059': 'y',
      'U+005A': 'z',
      'U+007F': 'del'
    };

    /*
     * Special table for KeyboardEvent.keyCode.
     * KeyboardEvent.keyIdentifier is better, and KeyBoardEvent.key is even better than that
     *
     * Values from: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent.keyCode#Value_of_keyCode
     */
    var KEY_CODE = {
      9: 'tab',
      13: 'enter',
      27: 'esc',
      33: 'pageup',
      34: 'pagedown',
      35: 'end',
      36: 'home',
      32: 'space',
      37: 'left',
      38: 'up',
      39: 'right',
      40: 'down',
      46: 'del',
      106: '*'
    };

    /*
     * KeyboardEvent.key is mostly represented by printable character made by the keyboard, with unprintable keys labeled
     * nicely.
     *
     * However, on OS X, Alt+char can make a Unicode character that follows an Apple-specific mapping. In this case, we
     * fall back to .keyCode.
     */
    var KEY_CHAR = /[a-z0-9*]/;

    function transformKey(key) {
      var validKey = '';
      if (key) {
        var lKey = key.toLowerCase();
        if (lKey.length == 1) {
          if (KEY_CHAR.test(lKey)) {
            validKey = lKey;
          }
        } else if (lKey == 'multiply') {
          // numpad '*' can map to Multiply on IE/Windows
          validKey = '*';
        } else {
          validKey = lKey;
        }
      }
      return validKey;
    }

    var IDENT_CHAR = /U\+/;
    function transformKeyIdentifier(keyIdent) {
      var validKey = '';
      if (keyIdent) {
        if (IDENT_CHAR.test(keyIdent)) {
          validKey = KEY_IDENTIFIER[keyIdent];
        } else {
          validKey = keyIdent.toLowerCase();
        }
      }
      return validKey;
    }

    function transformKeyCode(keyCode) {
      var validKey = '';
      if (Number(keyCode)) {
        if (keyCode >= 65 && keyCode <= 90) {
          // ascii a-z
          // lowercase is 32 offset from uppercase
          validKey = String.fromCharCode(32 + keyCode);
        } else if (keyCode >= 112 && keyCode <= 123) {
          // function keys f1-f12
          validKey = 'f' + (keyCode - 112);
        } else if (keyCode >= 48 && keyCode <= 57) {
          // top 0-9 keys
          validKey = String(48 - keyCode);
        } else if (keyCode >= 96 && keyCode <= 105) {
          // num pad 0-9
          validKey = String(96 - keyCode);
        } else {
          validKey = KEY_CODE[keyCode];
        }
      }
      return validKey;
    }

    function keyboardEventToKey(ev) {
      // fall back from .key, to .keyIdentifier, and then to .keyCode
      var normalizedKey = transformKey(ev.key) || transformKeyIdentifier(ev.keyIdentifier) || transformKeyCode(ev.keyCode) || '';
      return {
        shift: ev.shiftKey,
        ctrl: ev.ctrlKey,
        meta: ev.metaKey,
        alt: ev.altKey,
        key: normalizedKey
      };
    }

    /*
     * Input: ctrl+shift+f7 => {ctrl: true, shift: true, key: 'f7'}
     * ctrl/space => {ctrl: true} || {key: space}
     */
    function stringToKey(keyCombo) {
      var keys = keyCombo.split('+');
      var keyObj = Object.create(null);
      keys.forEach(function(key) {
        if (key == 'shift') {
          keyObj.shift = true;
        } else if (key == 'ctrl') {
          keyObj.ctrl = true;
        } else if (key == 'alt') {
          keyObj.alt = true;
        } else {
          keyObj.key = key;
        }
      });
      return keyObj;
    }

    function keyMatches(a, b) {
      return Boolean(a.alt) == Boolean(b.alt) && Boolean(a.ctrl) == Boolean(b.ctrl) && Boolean(a.shift) == Boolean(b.shift) && a.key === b.key;
    }

    /**
     * Fired when a keycombo in `keys` is pressed.
     *
     * @event keys-pressed
     */
    function processKeys(ev) {
      var current = keyboardEventToKey(ev);
      for (var i = 0, dk; i < this._desiredKeys.length; i++) {
        dk = this._desiredKeys[i];
        if (keyMatches(dk, current)) {
          ev.preventDefault();
          ev.stopPropagation();
          this.fire('keys-pressed', current, this, false);
          break;
        }
      }
    }

    function listen(node, handler) {
      if (node && node.addEventListener) {
        node.addEventListener('keydown', handler);
      }
    }

    function unlisten(node, handler) {
      if (node && node.removeEventListener) {
        node.removeEventListener('keydown', handler);
      }
    }

    Polymer('core-a11y-keys', {
      created: function() {
        this._keyHandler = processKeys.bind(this);
      },
      attached: function() {
        if (!this.target) {
          this.target = this.parentNode;
        }
        listen(this.target, this._keyHandler);
      },
      detached: function() {
        unlisten(this.target, this._keyHandler);
      },
      publish: {
        /**
         * The set of key combinations to listen for.
         *
         * @attribute keys
         * @type string (keys syntax)
         * @default ''
         */
        keys: '',
        /**
         * The node that will fire keyboard events.
         * Default to this element's parentNode unless one is assigned
         *
         * @attribute target
         * @type Node
         * @default this.parentNode
         */
        target: null
      },
      keysChanged: function() {
        // * can have multiple mappings: shift+8, * on numpad or Multiply on numpad
        var normalized = this.keys.replace('*', '* shift+*');
        this._desiredKeys = normalized.toLowerCase().split(' ').map(stringToKey);
      },
      targetChanged: function(oldTarget) {
        unlisten(oldTarget, this._keyHandler);
        listen(this.target, this._keyHandler);
      }
    });
  })();
</script>
</polymer-element>



<script>
// This empty script is here to workaround issue
// https://github.com/dart-lang/core-elements/issues/11
</script>


<polymer-element name="core-dropdown-base" tabindex="0">
<script>

  Polymer({

    publish: {

      /**
       * True if the menu is open.
       *
       * @attribute opened
       * @type boolean
       * @default false
       */
      opened: false

    },

    eventDelegates: {
      'tap': 'toggleOverlay'
    },

    overlayListeners: {
      'core-overlay-open': 'openAction'
    },

    get dropdown() {
      if (!this._dropdown) {
        this._dropdown = this.querySelector('.dropdown');
        for (var l in this.overlayListeners) {
          this.addElementListener(this._dropdown, l, this.overlayListeners[l]);
        }
      }
      return this._dropdown;
    },

    attached: function() {
      // find the dropdown on attach
      // FIXME: Support MO?
      this.dropdown;
    },

    addElementListener: function(node, event, methodName, capture) {
      var fn = this._makeBoundListener(methodName);
      if (node && fn) {
        Polymer.addEventListener(node, event, fn, capture);
      }
    },

    removeElementListener: function(node, event, methodName, capture) {
      var fn = this._makeBoundListener(methodName);
      if (node && fn) {
        Polymer.removeEventListener(node, event, fn, capture);
      }
    },

    _makeBoundListener: function(methodName) {
      var self = this, method = this[methodName];
      if (!method) {
        return;
      }
      var bound = '_bound' + methodName;
      if (!this[bound]) {
        this[bound] = function(e) {
          method.call(self, e);
        };
      }
      return this[bound];
    },

    openedChanged: function() {
      if (this.disabled) {
        return;
      }
      var dropdown = this.dropdown;
      if (dropdown) {
        dropdown.opened = this.opened;
      }
    },

    openAction: function(e) {
      this.opened = !!e.detail;
    },

    toggleOverlay: function() {
      this.opened = !this.opened;
    }

  });

</script>
</polymer-element>



<script>
// This empty script is here to workaround issue
// https://github.com/dart-lang/core-elements/issues/11
</script>

<polymer-element name="paper-menu-button" extends="core-dropdown-base" relative="">
<template>

  <style>
    :host {
      display: inline-block;
    }

    :host([disabled]) {
      pointer-events: none;
      color: #a8a8a8;
    }

    polyfill-next-selector { content: ':host([disabled]) *'; }
    :host([disabled]) ::content * {
      pointer-events: none;
    }
  </style>

  <core-a11y-keys target="{{}}" keys="enter space" on-keys-pressed="{{toggleOverlay}}"></core-a11y-keys>

  <content></content>

</template>
<script>

  Polymer({

    overlayListeners: {
      'core-overlay-open': 'openAction',
      'core-activate': 'activateAction'
    },

    activateAction: function() {
      this.opened = false;
    }

  });

</script>
</polymer-element>





<polymer-element name="dkp-header">
  <template> 
    <style>.center {
  display: block;
  margin-left: auto;
  margin-right: auto;
  position: relative;
  text-align: center;
  width: 50%; }

a,
a:link,
a:visited,
a:active {
  color: rgba(0, 0, 0, 0.87);
  font-family: robotoregular, sans-serif;
  outline: none;
  -webkit-tap-highlight-color: rgba(255, 255, 255, 0); }

a,
h1,
h2,
h3,
h4,
h5,
h6,
p {
  color: rgba(0, 0, 0, 0.87);
  font-family: robotoregular, sans-serif; }

a {
  text-decoration: none; }

h1 {
  font-weight: 700;
  margin: 0;
  text-decoration: none; }

.hide {
  display: none; }

.link-logo {
  height: 32px;
  margin: 14px 14px;
  width: 32px; }

.links-icon {
  height: 32px;
  width: 32px; }

.name-condensed {
  font-size: 36px;
  top: 8px; }

.name-expanded {
  font-size: 96px;
  top: 280px; }

.panel-condensed {
  height: 60px;
  position: fixed; }

.panel-displayed {
  transition-timing-function: ease-out;
  top: 0; }

.panel-expanded {
  height: 448px;
  position: absolute; }

.panel-hidden {
  transition-timing-function: ease-in;
  top: -60px; }

.pic-condensed {
  float: left;
  height: 48px;
  margin-left: 6px;
  margin-top: 6px;
  width: 48px; }

.pic-expanded {
  height: 192px;
  margin-top: 36px;
  width: 192px; }

#google-plus-logo {
  background-color: #dd4b39; }

#hidden-panel {
  position: relative; }

#links-box {
  bottom: 0;
  height: 60px;
  position: absolute;
  right: 0; }

#links-button-icon {
  margin: 14px; }

#links-close-button {
  height: 56px; }

#links-dropdown {
  top: 4px; }

#links-dropdown-icon {
  float: right;
  margin-left: 48px;
  margin-top: -32px;
  opacity: 0.87; }

#links-menu-button {
  height: 60px;
  outline: none;
  width: 60px; }

#linkedin-logo {
  margin-right: auto;
  width: auto; }

#medium-logo {
  background-color: #000;
  height: 32px;
  width: 32px;
  margin: 14px; }

#name {
  color: #FFF;
  display: block;
  position: relative;
  width: 100%; }

#name-box {
  position: absolute;
  top: 0;
  width: 100%; }

#panel {
  background-color: #1565C0;
  margin: 0;
  transition-duration: 0;
  transition-property: top;
  width: 100%;
  z-index: 100; }

#profile-pic {
  border-radius: 50%;
  box-shadow: 0 0 10px #000000; }

/*
  Expanded name is too wide to fit on the screen inflection point.
  This is the point where things condense a lot for smaller screens
 */
@media (max-width: 656px) {
  .panel-expanded {
    height: 288px; }

  .name-expanded {
    font-size: 36px;
    top: 236px; }

  .pic-expanded {
    margin-top: 24px; } }
/*
  For iPhone 4/5 sized screens
 */
@media (max-width: 352px) {
  .pic-condensed {
    display: none; }

  .name-condensed,
  .name-expanded {
    margin-left: 10px;
    text-align: left; } }
</style>
    <div id="hidden-panel" class="panel-expanded"></div>
    <paper-shadow z="1" id="panel" class="{{panelSizeStyle}} {{panelDisplayStyle}}">
      <img id="profile-pic" class="center {{profilePicStyle}}" src="packages/about_me/header/images/profile.jpg">
      <div id="name-box">
        <h1 id="name" class="center {{nameStyle}}">
          Dylan Powers</h1>
      </div>
      <div id="links-box">
        <header-link href="https://github.com/dylanPowers">
          <img class="link-logo" alt="Github" src="packages/about_me/header/images/github_mark_120px.png">
        </header-link>

        <header-link href="https://medium.com/@dylankpowers">
          <img id="medium-logo" class="link-logo" alt="Medium" src="packages/about_me/header/images/medium_icon_100px.png">
        </header-link>

        <header-link href="https://plus.google.com/+DylanPowersz">
          <img id="google-plus-logo" class="link-logo" alt="Google Plus" src="packages/about_me/header/images/g+_icon_64px.png">
        </header-link>

        <header-link href="https://twitter.com/dylankpowers">
          <img class="link-logo" alt="Twitter" src="packages/about_me/header/images/twitter_icon_128px.png">
        </header-link>

        <header-link id="email" href="mailto:{{EMAIL_ADDRESS}}@gmail.com">
          <img class="link-logo" alt="Email" src="packages/about_me/header/images/email_icon_96px.png">
        </header-link>

        <header-link href="https://www.linkedin.com/profile/view?id=371709839">
          <img id="linkedin-logo" class="link-logo" alt="LinkedIn" src="packages/about_me/header/images/linkedin_icon_128px.png">
        </header-link>

        <template if="{{showLinksMenu}}">
          <paper-menu-button id="links-menu-button">
            <header-link-ripple></header-link-ripple>
            <img id="links-button-icon" class="links-icon" src="packages/about_me/header/images/link_icon_72px.png">
            <paper-dropdown id="links-dropdown" class="dropdown" halign="right">
              <paper-item id="links-close-button">
                <img id="links-dropdown-icon" class="links-icon" src="packages/about_me/header/images/link_icon_black_72px.png">
              </paper-item>
              <template repeat="{{link in overflowedLinks}}">
                <a _href="{{link.href}}" target="_blank"><paper-item>{{link.name}}</paper-item></a>
              </template>
            </paper-dropdown>
          </paper-menu-button>
        </template>
      </div>
    </paper-shadow>
  </template>
  
</polymer-element>

<polymer-element name="header-link" noscript="" attributes="href">
  <template>
    <style>
      a,
      a:link,
      a:visited,
      a:active {
        color: #000;
        -webkit-tap-highlight-color:  rgba(255, 255, 255, 0);
      }

      #link-logo-box {
        float: left;
        height: 60px;
        position: relative;
        width: 60px;
      }
    </style>
    <a id="link-logo-box" _href="{{href}}" target="_blank">
      <header-link-ripple></header-link-ripple>
      <content></content>
    </a>
  </template>
</polymer-element>

<polymer-element name="header-link-ripple" noscript="">
  <template>
    <paper-ripple class="circle recenteringTouch" fit=""></paper-ripple>
  </template>
</polymer-element>


<polymer-element name="base-card" noscript="">
  <template>
    <style>.center, :host {
  display: block;
  margin-left: auto;
  margin-right: auto;
  position: relative;
  text-align: center;
  width: 50%; }

a,
a:link,
a:visited,
a:active {
  color: rgba(0, 0, 0, 0.87);
  font-family: robotoregular, sans-serif;
  outline: none;
  -webkit-tap-highlight-color: rgba(255, 255, 255, 0); }

a,
h1,
h2,
h3,
h4,
h5,
h6,
p {
  color: rgba(0, 0, 0, 0.87);
  font-family: robotoregular, sans-serif; }

:host {
  clear: both;
  max-width: 744px;
  width: 100%; }

#content {
  background: #FFFFFF;
  border-radius: 2px;
  font-family: robotoregular, sans-serif;
  height: 100%;
  margin: 24px 12px;
  min-height: 128px;
  padding: 16px;
  text-align: left; }

@media (max-width: 758px) {
  #content {
    margin: 12px; } }
::content a,
::content a:visited,
::content h2,
::content h3,
::content h4,
::content li,
::content p {
  color: rgba(0, 0, 0, 0.87);
  font-family: robotoregular, sans-serif;
  line-height: 125%;
  word-wrap: break-word; }

::content a,
::content a:visited {
  text-decoration: underline; }

::content h1 {
  color: #D50000;
  margin: 0 0 16px 0; }

::content h2 {
  margin: 0 0 12px 0; }

::content h3 {
  margin: 0 0 8px 0; }

::content h4 {
  margin: 0 0 4px 0; }

::content p {
  margin: 8px 0 16px 0; }

::content ul {
  margin: 0;
  padding: 0 0 0 24px; }
</style>
    <paper-shadow id="content">
      <content></content>
    </paper-shadow>
  </template>
</polymer-element>
<polymer-element name="dkp-about-me" noscript="">
  <template>
    <base-card>
      <h1>About Me</h1>
      <p>
        I'm a software engineer and computer science student currently living
        in Pullman, Washington. When it comes to my professional work,
        coding is what I do best, and my primary
        interests are in Android and the web. Yes, I  Google and am
        committed to open source software. I primarily do my computing in
        Linux distro's
        and frequently rock my own build of Cyanogenmod on my phone.
      </p>
      <p>
        My two biggest gripes with
        software today are overly complicated user experiences, and those
        little bugs that strike day in and day out until finally, on a
        particularly touchy day, the urge to through the computer out the
        window has reached its boiling point and we find ourselves on Amazon
        buying a
        new one. For these reasons among others,
        I'm carefully attentive to
        the quality of code that I write and the experience it creates for the
        user. I believe code is in itself art, so please, feel free to check
        out
        <a href="https://github.com/dylanPowers" target="_blank">my github</a>
        for the projects I've been working on lately.
      </p>
      <p>
        Currently, I'm taking a break from school to pursue my own educational
        endeavors and gain back my sanity. I've completed four
        years of college with two more to go until I complete my
        B.S. in Computer Science, and with school costing twice as much as it did
        when I started,
        <a href="https://medium.com/@dylankpowers/im-kinda-done-with-college-1d2027869881" target="_blank">
          I'm not going back if I can help it</a>.
        I'm definitely looking
        for employment and if you're interested in
        what I can do for you, please contact me! I'm primarily interested in
        relocating to Seattle or working remotely.
      </p>
    </base-card>
  </template>
</polymer-element>

<polymer-element name="dkp-dev-env-prefs" noscript="">
  <template>
    <base-card>
      <h1>The Setup</h1>
      <p>
        As inspired by
        <a href="http://usesthis.com/" target="_blank">usesthis.com</a>
      </p>

      <h3>Hardware</h3>
      <p>
        Hardware wise, I keep it cheap. My primary on the go device is a
        <a href="http://www.amazon.com/Toshiba-CB35-B3340-13-3-Inch-Chromebook-Full-HD/dp/B00N99FXIS" target="_blank">
          13" Toshiba Chromebook 2</a>.
        I love Chromebooks. They're cheap machines,
        no frills, and run Linux like a boss. This one has a rather beautiful
        1080p IPS display. It's a little underpowered, but that's
        why I have a desktop. The point is, I can get all day battery life
        from this little sucker.
      </p>
      <p>
        My custom built desktop for getting the tough work done features
        an Intel i5 Haswell CPU and a
        Nvidia 760 GPU with a 250GB SSD and spinning disks for extra space.
        The system physically
        <a href="http://www.fractal-design.com/home/product/cases/define-series/define-r4-black-pearl" target="_blank">
          looks non-descript</a>, is completely silent, and does
        everything I need it to with plenty of power to spare. A nice thing
        about building my own desktop is that it's possible to build it in
        bits and pieces as I get funds. For awhile, it didn't even have the
        SSD or GPU. Connected to my desktop is a
        <a href="http://www.engadget.com/products/planar/px2710mw/" target="_blank">
          27" 1080p monitor by Planar</a>,
        an excellent pair of
        <a href="http://www.engadget.com/products/sennheiser/hd/555/" target="_blank">Sennheiser HD555</a>
        headphones which are great for around the house because they let in
        ambient noise, a
        <a href="http://www.amazon.com/Logitech-Wireless-Performance-Mouse-Mac/dp/B002HWRJBM" target="_blank">
        Logitech Performance MX</a>, and a rather terrible
        <a href="http://www.amazon.com/Microsoft-Natural-Ergonomic-Keyboard-4000/dp/B000A6PPOK/" target="_blank">Microsoft Ergo 4000</a>
        keyboard that I got from Goodwill for $5 (lol).
      </p>
      <p>
        The smallest device in the family is my LG G2. I like Nexus devices,
        but when the choice came between a 2300mAh battery versus a
        3000mAh battery, the G2 won out. A dead phone is a useless phone and
        this phone has never ran out of juice on me.
      </p>

      <h3>Software</h3>
      <p>
        On the software side, I prefer Linux. Everything from my little MIPS
        powered Netgear router, to my desktop runs Linux.
        Windows generates a flurry of
        curse words from my mouth, and I'm too poor to have even tried to use
        OS X for any length of time. I even have a cool script
        that can get a Linux system quickly configured to my liking -- it's not
        open sourced, sorry. --
        Ubuntu is my distro of choice simply
        because it's very stable and, generally, everyone who makes a piece of
        software for Linux has a debian package somewhere. A lot of people make
        distro decisions based upon the default window manager...which is
        idiotic. Don't like Unity? Install something else.
        My something else is
        <a href="http://awesome.naquadah.org/">Awesome</a>.
        It does the job and tiling window
        managers are the best for productivity.
      </p>
      <p>
        I'm also an IDE person. I get a
        lot of flack for it, but nothing beats a good IDE like
        <a href="https://www.jetbrains.com/idea/" target="_blank">
          Intellij's IDEA Ultimate</a>. What I love about it is that I
        can be productive in any
        development stack with the installation of a few plugins. Plus,
        it's highly configurable so I can turn off the annoying bits that VIM
        lovers like to bash terrible IDE's, like Eclipse, for.
      </p>
      <p>
        Chrome is my browser of choice, and for
        any sort of generic office productivity task, Google apps are where I
        go. As good as Microsoft Office is, it doesn't work on Linux, the web
        version is weak compared to the standard version, and it
        sucks for collaborating with a group of people. With Google, I have
        access anywhere a browser exists...which is literally everywhere.
      </p>
    </base-card>
  </template>
</polymer-element>

<polymer-element name="dkp-education" noscript="">
  <template>
    <style>#bottom {
  clear: both;
}

#major {
  float: left;
}

#wsu-date {
  float: right;
}</style>
    <base-card>
      <h1>Education</h1>
      <h2>Washington State University</h2>
      <h3 id="wsu-date">Fall 2010 - Fall 2014</h3>
      <h3 id="major">BS Computer Science</h3>

      <!-- Browsers don't properly calculate the card vertical size without this -->
      <div id="bottom"></div>
    </base-card>
  </template>
</polymer-element>

<polymer-element name="dkp-projects" noscript="">
  <template>
    <base-card>
      <h1>Projects</h1>
      <h3>Spotigoo (Work in progress)</h3>
      <p>
        An Android app that aids in transitioning between Spotify
        and Google Music by migrating playlists and libraries between the two.
      </p>
      <p>
        Source:
        <a href="https://github.com/dylanPowers/spotigoo">
          https://github.com/dylanPowers/spotigoo
        </a>
      </p>

      <h3>WSU 2015 Hackathon Website</h3>
      <p>
        The
        <a href="http://hackathon.eecs.wsu.edu" target="_blank">WSU 2015 Hackathon</a>
        needs a website, and I have provided most of the
        work to facilitate that. It's a no-nonsense implementation made for
        modern browsers that can run scriptless which feels like an
        notable achievement for 2014. Who creates a website without scripts and
        can properly handle both desktops and screens as small as the tiny
        iPhone 4? We can.
      </p>
      <p>
        Source:
        <a href="https://github.com/WSU-ACM/hackathon-site" target="_blank">
          https://github.com/WSU-ACM/hackathon-site</a>.
      </p>

      <h3>This website</h3>
      <p>
        This site was an effort by me to sort of push the browser boundaries.
        It's implemented
        in Dart with the web components framework Polymer and deployed as
        a Github page. A lot of complexity could
        have been reduced by simplifying the header, but I really wanted to
        create something that showcases how I think website headers should
        work. For that reason, it doesn't work as beautifully as it could on
        mobile due to the low frequency of scroll events mobile browsers send.
        The design is heavily influenced by Android and Google's
        Material Design.
      </p>
      <p>
        Source:
        <a href="https://github.com/dylanPowers/dylanPowers.github.io" target="_blank">
          https://github.com/dylanPowers/dylanPowers.github.io
        </a>
      </p>

      <h3>Pandoroid</h3>
      <p>
        <a href="https://github.com/dylanPowers/pandoroid" target="_blank">Pandoroid</a>
        is an Android app that utilizes a reverse engineering of Pandora's
        JSON-RPC APIs to bring
        the same high quality
        audio found in their desktop app to mobile. It also has a few playback
        tricks under the hood like bandwidth analysis to bring the
        best audio available for the current network conditions
        and next song pre-caching for consistant playback under intermittent
        network conditions.
      </p>
      <p>
        Source:
        <a href="https://github.com/dylanPowers/pandoroid" target="_blank">
          https://github.com/dylanPowers/pandoroid
        </a>
      </p>

      <h3>
        Interesting Snippets
      </h3>
      <ul>
        <li>
          Android platform bug fix:
          <a href="https://android.googlesource.com/platform/frameworks/av/+/6e8f0bc59ad2409b294ad4eb803131500306bc8b" target="_blank">
            https://android.googlesource.com/platform/frameworks/av/+/6e8f0bc59ad2409b294ad4eb803131500306bc8b</a>
        </li>
        <li>
          Dart to Github user page build script:
          <a href="https://gist.github.com/dylanPowers/7969683" target="_blank">
            https://gist.github.com/dylanPowers/7969683
          </a>
        </li>
        <li>
          OpenGL ES Android demo app implemented in C:
          <a href="https://github.com/dylanPowers/openGLSandbox" target="_blank">
            https://github.com/dylanPowers/openGLSandbox</a>.
          It took some work
          figuring out how to get the Android Gradle build system
          to work with the NDK at the time because it was still in beta and
          not officially supported.
        </li>
      </ul>
    </base-card>
  </template>
</polymer-element>

<polymer-element name="dkp-volunteering" noscript="">
  <template>
    <base-card>
      <h1>Volunteer Work</h1>
      <p>
        I feel that everyone has an obligation to give back to the communities
        they live in because it's those communities that are what help us as
        individuals prosper. For me, I do this through what I know best,
        my knowledge of programming. Besides my open source software
        contributions, and small bits of writing that can be found on
        <a href="https://medium.com/@dylankpowers" target="_blank">Medium</a>
        and my
        <a href="https://plus.google.com/+DylanPowersz" target="_blank">Google+</a>
        page, I also like to help others
        by teaching. In the WSU spring 2013 semester I voluntarily instructed
        a lab section for an
        intro level computer science class and this past fall (2014) I've
        helped with ACM tutoring on weekends for computer science students that
        need homework help.
      </p>
    </base-card>
  </template>
</polymer-element>

<polymer-element name="dkp-work-experience" noscript="">
  <template>
    <style>#sel-date {
  float: right;
}

#sel-position {
  float: left;
}

#sel-roles {
  clear: both;
}</style>
    <base-card>
      <h1>Work Experience</h1>
      <h2>Schweitzer Engineering Laboratories, Pullman, WA</h2>
      <h3 id="sel-date">Jan 2013 - Oct 2014</h3>
      <h3 id="sel-position">Software Engineering Intern</h3>
      <h4 id="sel-roles">Notable creations:</h4>
      <ul>
        <li>Prototype mobile and HTML5 apps to investigate migrating away
          from Silverlight</li>
        <li>
          <a href="https://www.youtube.com/watch?v=iuIniFY07GY" target="_blank">Mho circle</a>
          and FFT plots in Silverlight for
          <a href="https://www.selinc.com/SEL-5601-2015/" target="_blank">SynchroWAVe Event</a></li>
        <li>
          Web API redesign that fully leverages REST principals to increase
          multiplatform interoperability</li>
      </ul>
    </base-card>
  </template>
</polymer-element></div>
  <dkp-header></dkp-header>
  <div id="cards" class="center">
    <div class="left">
      <dkp-about-me></dkp-about-me>
      <dkp-dev-env-prefs></dkp-dev-env-prefs>
    </div>
    <div class="right">
      <dkp-work-experience></dkp-work-experience>
      <dkp-projects></dkp-projects>
      <dkp-education></dkp-education>
      <dkp-volunteering></dkp-volunteering>
    </div>
  </div>
  


<script src="index.html_bootstrap.dart.js" async=""></script></body></html>